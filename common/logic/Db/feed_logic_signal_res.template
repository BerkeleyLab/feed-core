# feed_logic_signal.template
# BASE="$(BASE)", NAME="$(NAME)", REG="$(REG)", SIZE="$(SIZE)"
# IDX="$(IDX=default)", MASK="$(MASK=default)"

# One logical signal (or many?) in an array register
#
# Entry point: "$(BASE)E_"
#
# Required Macros:
#   BASE - common record prefix
#   NAME - FEED device instance name
#   REG  - register name
#   SIZE - max. register size (in elements)
#   MASKSET - Record name of mbboDirect signal selection mask.
#   MASKBIT - Bit in selection mask.
#
# Optional Macros:
#   IDX - index of this signal in mask register, or index of first sample if no mask register.
#   MASK - Link (including 'CP MS') to signal selection mask readback.
#   FLNK - Next record in chain after waveform update

# calculate de-mux offset and step

# Future, if per-cavity per-signal enable control supported
# If so, remove/modify per-signal enable in res_wf_support.template
#record(bo, "$(BASE)ENABLE") {
#  field(ZNAM, "Disable")
#  field(ONAM, "Enable")
#  field(OUT, "$(MASKSET).B$(MASKBIT) PP")
#  field(VAL , "1") # initially Enable
#  field(PINI, "YES")
#}

record(longin, "$(BASE)CONFIG_") {
    # monitor offset computed in feed_wf_acquire_base.template
    field(INP , "$(SELPREF)MASK_.VAL$(LETTER) CP")
    field(TPRO, "$(TPRO=0)")
    field(FLNK, "$(BASE)OFFSET")
}

record(longout, "$(BASE)OFFSET") {
    # scan disable when this signal is not selected
    field(SDIS, "$(BASE)CONFIG_")
    field(DISV, "-1")

    field(DTYP, "FEED Signal Offset")
    field(OUT , "@signal=$(BASE)")
    field(OMSL, "closed_loop")
    field(DOL , "$(SELPREF)MASK_.VAL$(LETTER)")
    field(FLNK, "$(BASE)STEP")
}

record(longout, "$(BASE)STEP") {
    field(DTYP, "FEED Signal Step")
    field(OUT , "@signal=$(BASE)")
    field(OMSL, "closed_loop")
    field(DOL , "$(SELPREF)MASK_.VALA MSI")
    field(FLNK, "")
}

# scaling factor

# User scaling factor, applied along with full scale
# computed for decimation (wave_samp_per)
# Scale from ARB [0, 1) -> EGU
record(ao, "$(BASE)SCALE") {
    field(VAL , "$(SCALE=1.0)")
    field(PREC, "9")
    field(FLNK, "$(BASE)SCALE_CALC_")
#    info(autosaveFields_pass0, "VAL")
}

record(calcout, "$(BASE)SCALE_CALC_") {
    field(INPA, "$(BASE)SCALE NPP MSI")
    field(INPB, "$(PREF)ACQ_AMPCALC.VALB CP MSI")
    # take the full scale value and compute our scaling factor
    field(CALC, "A/B")
    # if for some reason we get a junk (INVALID) scaling factor, default to 1.0
    field(IVOA, "Set output to IVOV")
    field(IVOV, "1.0")
    field(OUT , "$(BASE)SCALE_RBV PP")
}

# readback of actual scaling factor used
# from ADC -> EGU
record(ao, "$(BASE)SCALE_RBV") {
    field(DTYP, "FEED Signal Scale")
    field(OUT , "@signal=$(BASE)")
    field(VAL , "1.0")
    field(PREC, "9")
}

# Signal readout

record(aai, "$(BASE)WF") {
    # scan disable when this signal is not selected
    field(SDIS, "$(BASE)CONFIG_")
    field(DISV, "-1")

    field(DTYP, "FEED Register Read")
    field(DESC, "$(DESC=Reg $(NAME))")

    # wait=false uses cached value
    field(INP , "@name=$(NAME) reg=$(REG) signal=$(BASE) wait=false")
    field(FTVL, "DOUBLE")
    field(NELM, "$(SIZE)")
    field(TSE , "-2")

    alias("$(BASE)E_")

    field(FLNK, "$(BASE)NORD")
}

# workaround for bug in aaiRecord.  doesn't post monitors on NORD
record(longin, "$(BASE)NORD") {
    field(INP , "$(BASE)WF.NORD")

    field(FLNK, "$(FLNK=)")
}

# timebase

record(aSub, "$(BASE)TWF_") {
    field(SNAM, "asub_feed_timebase")
    # first value
    field(FTA , "DOUBLE")
    field(INPA, "0.0")
    # step size
    field(FTB , "DOUBLE")
    field(INPB, "$(TBREF=1.0)")
    # element count
    field(FTC , "ULONG")
    field(INPC, "$(BASE)NORD CP MSI")
    # step size divider
    field(FTD , "DOUBLE")
    field(INPD, "$(TBDIV=1.0)")
    # output array
    field(FTVA, "DOUBLE")
    field(NOVA, "$(SIZE)")
    field(OUTA, "$(BASE)TWF PP MSI")
}

record(aai, "$(BASE)TWF") {
    field(FTVL, "DOUBLE")
    field(NELM, "$(SIZE)")
    field(TSEL, "$(BASE)TWF_.TIME")
}
