# waveform buffer handling
#
# Write channel select mask to shell_#_dsp_chan_keep
#
# Write one to bit N in circle_buf_flip to enable acquisition of channel N
#
# Wait for bit N in llrf_circle_ready to be set
#
# Macros
#  BASE - Record name prefix
#  NAME - FEED Device name
#  BIT  - Channel bit number (0 is first channel)
#  MASK - Channel bit mask (1 is first channel)
#  SIZE - Max signal length (eg. 8192)

# local (re)initialization

record(longin, "$(BASE)Init1_") {
    field(DTYP, "FEED On Connect")
    field(INP , "@name=$(NAME)")
    field(SCAN, "I/O Intr")
    field(PHAS, "0")
    field(FLNK, "$(BASE)Init2_")
    field(TPRO, "$(TPRO=0)")
}

# push out channel mask and decimation factor
record(fanout, "$(BASE)Init2_") {
    field(LNK1, "$(BASE)Dec-SP")
    field(LNK2, "$(BASE)Mask-SP")
    field(LNK3, "")
    field(LNK4, "")
    field(LNK5, "")
    field(LNK6, "$(BASE)Mode-Sel")
    field(FLNK, "$(BASE)Init3_")
    field(TPRO, "$(TPRO=0)")
}

# wait for write completion before triggering first acquisition
record(longin, "$(BASE)Init3_") {
    field(DTYP, "FEED Sync")
    field(INP , "@name=$(NAME)")
    field(FLNK, "$(BASE)Mode-Sel")
    field(TPRO, "$(TPRO=0)")
}

# timebase logic

record(longout, "$(BASE)Dec-SP") {
    field(DTYP, "FEED Register Write")
    field(OUT , "@name=$(NAME) reg=shell_$(BIT)_dsp_wave_samp_per")
    field(VAL , "1")
    field(DRVH, "0xff")
    field(DRVL, "1")
    field(HOPR, "0xff")
    field(LOPR, "1")
    field(FLNK, "$(BASE)Per-I")
    field(TPRO, "$(TPRO=0)")
    info(autosaveFields_pass0, "VAL")
}

record(calc, "$(BASE)Per-I") {
    field(INPA, "$(BASE)Dec-SP")
    field(INPB, "33") # cic_base_period
    field(INPC, "94.29e6") # samp/sec
    field(CALC, "B*2*A/C")
    field(FLNK, "$(BASE)AmpCalc")
}

# amplitude

record(aSub, "$(BASE)AmpCalc") {
    field(SNAM, "asub_yscale")
    field(FTA , "ULONG") # wave_samp_per register
    field(INPA, "$(BASE)Dec-SP MSI NPP")
    field(FTB , "ULONG") # cic_period
    field(INPB, "33")
    field(FTVA, "ULONG") # wave_shift
    field(OUTA, "$(BASE)WaveShift-SP MSI PP")
    field(FTVB, "DOUBLE") # yscale  (referenced in feed_wf_acquire_signal.template)
}

record(longout, "$(BASE)WaveShift-SP") {
    field(DTYP, "FEED Register Write")
    field(OUT , "@name=$(NAME) reg=shell_$(BIT)_dsp_wave_shift")
    field(DRVL, "0")
    field(DRVH, "255")
}

# channel mask logic

record(mbboDirect, "$(BASE)Mask-SP") {
    field(DESC, "Channel selection bitmask")
    field(OUT , "$(BASE)Mask2_ PP")
    field(PINI, "YES")
    field(TPRO, "$(TPRO=0)")
    info(autosaveFields_pass0, "VAL B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA BB")
}

record(longout, "$(BASE)Mask2_") {
    field(DTYP, "FEED Register Write")
    field(OUT , "@name=$(NAME) reg=shell_$(BIT)_dsp_chan_keep")
    field(FLNK, "$(BASE)Mask3_")
    field(TPRO, "$(TPRO=0)")
}

record(aSub, "$(BASE)Mask3_") {
    field(SNAM, "asub_split_bits")
    field(FTA , "LONG")
    field(INPA, "$(BASE)Mask2_ NPP")
    field(FTVA, "LONG")
    field(FTVB, "LONG")
    field(FTVC, "LONG")
    field(FTVD, "LONG")
    field(FTVE, "LONG")
    field(FTVF, "LONG")
    field(FTVG, "LONG")
    field(FTVH, "LONG")
    field(FTVI, "LONG")
    field(FTVJ, "LONG")
    field(FTVK, "LONG")
    field(FTVL, "LONG")
    field(FTVM, "LONG")
    # individual signals monitor one of VALB -> VALM
    # to detect config changes
    field(EFLG, "ALWAYS")
}

# tag handling
# we manage the tag.  Clients may increment on request
# as part of acqusition update sequencing

record(busy, "$(BASE)TagInc-Cmd") {
    field(OUT , "$(BASE)TagInc-Calc_.PROC PP")
}

record(calcout, "$(BASE)TagInc-Calc_") {
    # prevent inc on cancel/complete
    field(SDIS, "$(BASE)TagInc-Cmd")
    field(DISV, "0")

    field(INPA, "$(BASE)TagInc-Calc_")
    field(INPB, "255")
    field(CALC, "A+1<=B?A+1:1") # 8 bit counter, overflows to 1 (0 means HW un-initialized)
    field(OUT , "$(BASE)Tag-RB PP")
}

record(longout, "$(BASE)Tag-RB") {
    field(DTYP, "FEED Register Write")
    field(OUT , "@name=$(NAME) reg=shell_$(BIT)_dsp_tag")
    field(FLNK, "$(BASE)TagDone-Cmd_")
    info(feed:info:input, "$(BASE)Tag-RB")
    info(feed:info:increment, "$(BASE)TagInc-Cmd")
}

# Complete TagInc
record(longout, "$(BASE)TagDone-Cmd_") {
    field(VAL, "0")
    field(OUT, "$(BASE)TagInc-Cmd PP")
}

# acquisition trigger logic

record(bo, "$(BASE)Mode-Sel") {
    field(ZNAM, "Single")
    field(ONAM, "Normal")
    field(VAL , "0")
    field(FLNK, "$(BASE)Acq-Cmd")
    info(autosaveFields_pass0, "VAL")
}

record(ao, "$(BASE)HldOff-SP") {
    field(DESC, "re-arm holdoff time")
    field(OUT , "$(BASE)AcqDly_.ODLY NPP")
    field(DRVH, "5.0")
    field(DRVL, "0.1")
    field(VAL , "1.0")
    field(EGU , "s")
    field(PREC, "2")
    info(autosaveFields_pass0, "VAL")
}

record(bo, "$(BASE)Acq-Cmd") {
    field(DESC, "Start aquisition")
    field(ZNAM, "Acquire")
    field(ONAM, "Acquire")
    field(FLNK, "$(BASE)Acq-Cmd_")
    field(TPRO, "$(TPRO=0)")
}

# write $(MASK) to reg circle_buf_flip
record(longout, "$(BASE)Acq-Cmd_") {
    field(DTYP, "FEED Register Write")
    field(OUT , "@name=$(NAME) reg=circle_buf_flip")
    field(VAL , "$(MASK)")
    field(FLNK, "$(BASE)Rdy-I_")
    field(TPRO, "$(TPRO=0)")
}

# wait for value & $(MASK) == $(MASK) for reg llrf_circle_ready
record(bo, "$(BASE)Rdy-I_") {
    field(DTYP, "FEED Register Watch")
    field(OUT , "@name=$(NAME) retry=0.1 reg=llrf_circle_ready mask=$(MASK) value=$(MASK)")
    field(FLNK, "$(BASE)CircRaw_")
    field(TPRO, "$(TPRO=0)")
}

# actual readback of sample buffer
record(aai, "$(BASE)CircRaw_") {
    field(SDIS, "$(BASE)Rdy-I_ MSI")
    field(DISV, "-42")

    field(DTYP, "FEED Register Read")
    field(DESC, "$(DESC=Reg $(NAME))")
    field(INP , "@name=$(NAME) reg=shell_$(BIT)_circle_data")
    field(FTVL, "DOUBLE")
    field(NELM, "$(SIZE)")
    field(TSE , "-2")
    field(FLNK, "$(BASE)SlowRaw_")
    field(TPRO, "$(TPRO=0)")
    info(feed:info:rawinput, "$(BASE)CircRaw_")
}

# actual readback of aggregated data block
record(aai, "$(BASE)SlowRaw_") {
    field(DTYP, "FEED Register Read")
    field(DESC, "$(DESC=Reg $(NAME))")
    field(INP , "@name=$(NAME) reg=shell_$(BIT)_slow_data")
    field(FTVL, "DOUBLE")
    field(NELM, "$(SIZE)")
    field(TSE , "-2")
    field(FLNK, "$(BASE)AcqCnt-I")
    field(TPRO, "$(TPRO=0)")
    info(feed:info:rawinput, "$(BASE)SlowRaw_")
}

# individual signals monitor this to detect new data
record(calc, "$(BASE)AcqCnt-I") {
    field(SDIS, "$(BASE)Rdy-I_ MSI")
    field(DISV, "-42")
    field(INPA, "$(BASE)AcqCnt-I")
    field(CALC, "A+1")
    field(FLNK, "$(BASE)AcqNext-FOut_")
    field(TPRO, "$(TPRO=0)")
}

record(calc, "$(BASE)AcqRate-I") {
    field(SCAN, "10 second")
    field(INPA, "$(BASE)AcqCnt-I")
    field(CALC, "C:=A-B;B:=A;C/10")
    field(EGU , "Hz")
    field(PREC, "2")
}

record(fanout, "$(BASE)AcqNext-FOut_") {
    field(LNK0, "$(LNK0=)")
    field(LNK1, "$(LNK1=)")
    field(LNK2, "$(LNK2=)")
    field(LNK3, "$(LNK3=)")
    field(LNK4, "$(LNK4=)")
    field(LNK5, "$(LNK5=)")
    field(LNK6, "$(LNK6=)")
    field(LNK7, "$(LNK7=)")
    field(LNK8, "$(LNK8=)")
    field(LNK9, "$(LNK9=)")
    field(LNKA, "$(LNKA=)")
    field(LNKB, "$(LNKB=)")
    field(FLNK, "$(BASE)AcqDly_")
}

record(calcout, "$(BASE)AcqDly_") {
    field(SDIS, "$(BASE)Mode-Sel")
    field(DISV, "0") # disable when Single
    field(CALC, "0")
    field(ODLY, "1.0")
    field(OUT , "$(BASE)Acq-Cmd PP")
    field(TPRO, "$(TPRO=0)")
}

# common window for all waveform stats

record(ao, "$(BASE)Stat:Start-SP") {
    field(PREC, "6")
    field(PINI, "YES")
    info(autosaveFields_pass0, "VAL")
}

record(ao, "$(BASE)Stat:Width-SP") {
    field(PREC, "6")
    field(VAL , "1") # default to a large value to include entire period
    field(PINI, "YES")
    info(autosaveFields_pass0, "VAL")
}
