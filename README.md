FPGA Embedded Ethernet Driver (FEED)
====================================

Author: Michael Davidsaver <mdavidsaver@ospreydcs.com>

Building
--------

Requires:

* EPICS Base >=3.15.1 https://epics.anl.gov/
* Busy https://github.com/epics-modules/busy
* zlib

```sh
sudo apt-get install libz-dev
cat <<EOF > configure/RELEASE.local
BUSY=/path/to/epics/busy
EPICS_BASE=/path/to/epics/base
EOF
make
```

Getting Started
---------------

Building FEED results in

* libfeed and feed.dbd for inclusion in IOCs
* leep.py CLI client tool
* feedsim Standalong device simulator
* feed_base.template A .db fragment for generic control/status
* feed_reg_*.template Fragments for use with templates generated by leep.py

To include in an IOC, add the following to eg. '<myname>App/src/Makefile'

```
<myioc>_DBD += feed.dbd
<myioc>_LIBS += feed
```

See feedApp/Makefile for an example.

FEED client instances are created automatically when records are loaded.
The device IP address is set dynamically through the "$(PREF)Addr-SP" in feed_base.template.
An initial value may be given with the "$(ADDR)" macro when loading this template.
Alternately, it can be written after loading.

A mimimal example using the provided demo IOC executable 'feedioc'.

```
#!../../bin/linux-x86_64-debug/feedioc
dbLoadDatabase("../../dbd/feedioc.dbd",0,0)
feedioc_registerRecordDeviceDriver(pdbbase)
dbLoadRecords("feed_base.template","PREF=TST:ctrl:,NAME=device")
iocInit()
dbpf "TST:ctrl:Addr-SP" "<device_hostname/IP>"
```

See the section on Status Monitoring for details on how to verify correct operation.

Device Supports
---------------

The format of all INP/OUT link fields is: "key=value key2=value2".
Allowed keys are:

* name=
* reg=
* offset=
* step=
* wait=
* mask=
* value=
* retry=
* scale=  (only for aai/aao w/ FTVL=DOUBLE)

All INP/OUT links must specify a Device name with 'name='.
Use of other keys is described in the following.

The Device Supports used only in feed_base.template are not described.

The Device Supports provided by feed.dbd are as follows.

### Register Write

To write value(s) to a Device register.

```
record(longout, "...") {
...
record(ao, "...") {
...
record(aao, "...") {
    field(DTYP, "FEED Register Write")
    field(OUT , "@name=<devicename> reg=<regname>")
    # optional in OUT
    #  offset=0  Index in register from which a (first) value taken
    #  wait=true Whether to delay completion until the write is acknowledged by the device.
    #  step=1  With aao, increment of Index between array elements
}
```

### Register Read

To read value(s) to a Device register.

```
record(longin, "...") {
...
record(ai, "...") {
...
record(aai, "...") {
    field(DTYP, "FEED Register Read")
    field(INP , "@name=<devicename> reg=<regname>")
    # optional in OUT
    #  offset=0  Index in register from which a (first) value taken
    #  wait=true Whether to read a value from the Device, or use the previous read value.
    #  step=1  With aai, increment of Index between array elements
}
```

### Register Watch

To periodically poll a status register until "current & <bitmask> == <expected>".

Every "<pollperiod>" seconds the register is read and compared.
Record processing does not complete until the condition is true, or a timeout occurs.

```
record(bo, "...") {
    field(DTYP, "FEED Register Watch")
    field(OUT , "@name=<devicename> reg=<regname> retry=<pollperiod> mask=<bitmask> value=<expected>")
    #  offset=0  Index in register from which a (first) value taken
}
```

### Sync

The special DTYP="FEED Sync" support exists to allow sequencing during (re)connection.
This asynchronous record will complete processing after every in-progress register read/write
can completed (or timed out).

```
record(longin, "$(BASE)Init3_") {
    field(DTYP, "FEED Sync")
    field(INP , "@name=$(NAME)")
}
```

### Signals

The Signals device supports allow some parameters specified in
an INP/OUT link to be changed after initialization via
a different record.

The association between two records is made with the 'signal=' parameter.
Which is a IOC wide unique identifier (unique to one of the  Register Read/Write DTYPs).

Signal names may be selected arbitrarily.
It is suggeste to use a combination of record name prefix,
device name, and/or register name.

In this example, the "$(P)Off-SP" controls, and overrides, the offset=
paramter for "$(P)-I".

```
record(aai, "$(P)-I") {
    field(DTYP, "FEED Register Read")
    field(INP , "@name=<devicename> reg=<regname> signal=$(P):<regname>")
    ...
}
register(longout, "$(P)Off-SP") {
    field(DTYP, "FEED Signal Offset")
    field(OUT , "@signal=$(P):<regname>")
    ...
}
```

Currently only the offset, step=, and scale= parameters may be override via the Signals mechanism.

Status Monitoring
-----------------

Basic status is reported through the "$(PREF)State-Sts" record.
This will show the current state of the device state machine:

* Error - Internal software fault occurs.  Write "$(PREF)Rst-Cmd" to clear.
* Idle - No IP address set with "$(PREF)Addr-SP"
* Searching - Waiting for initial response from Device
* Inspecting - Downloading ROM
* Running - Normal operating mode


### Counters

A number of event counters are provided.
These include number of packets sent and received, as well as number of timeouts.
Counters are exposed through records in 'feed_base.template' and by 'dbior'.

### dbior

The 'dbior' IOC shell command will give infomation about all FEED Devices.

Tools
-----

```sh
$ ./leep.py -h
usage: leep.py [-h] [-d] [-q] [-l] [-t TIMEOUT]
               host[:port] {reg,list,dump,json,template} ...

positional arguments:
  host[:port]           Server address
  {reg,list,dump,json,template}
    reg                 read/write registers
    list                list registers
    dump                dump registers
    json                print json
    template            Generate MSI substitutions file

optional arguments:
  -h, --help            show this help message and exit
  -d, --debug
  -q, --quiet
  -l, --list            List register names
  -t TIMEOUT, --timeout TIMEOUT
```

```sh
$ ./bin/linux-x86_64/feedsim -h
Usage: ./bin/linux-x86_64/feedsim [-hd] [-H <iface>[:<port>]] <json_file> [initials_file]
```

Simulator Usage
---------------

A JSON file is needed to run the simulator.
Either extract one from a live device with `leep.py list` or
use the testing file.

```sh
./bin/linux-x86_64/feedsim tests/jblob.json
```

In another terminate run:

To dump register infomation as JSON.

```sh
./leep.py localhost list
```

To read register(s) by name or address.
Example names token from tests/jblob.json

```sh
./leep.py localhost reg prc_dsp_prl_gain trace_i_buf
prc_dsp_prl_gain[0]     00000000
 ...
```

To write a register

```sh
$ ./leep.py localhost reg prc_dsp_prl_gain prc_dsp_prl_gain=42 prc_dsp_prl_gain
prc_dsp_prl_gain[0]     00000000
prc_dsp_prl_gain[0]     0000002a
prc_dsp_prl_gain[0]     0000002a
```

To print all non-zero register values in a format suitable
to use simulator initial values.

```sh
./leep.py localhost dump -Z > initial.dat
```

Simulator Logic
^^^^^^^^^^^^^^^

The simulator can be made to simulator some of the register handling logic
of some devices.  Currently only the RFS waveform acquisition logic is modeled.

The argument -L <name> is used to enable logic handling.
This will fail if the loaded register description doesn't
include all necessary registers.

eg.


```sh
./bin/linux-x86_64/feedsim -L rfs tests/jblob.json
```


Snapshot and Simulate
---------------------

To snapshot a actual device for simulation, run:

```sh
./leep.py <ip> json > capture.json
./leep.py <ip> dump -Z > capture.initial
```

This snapshot can then be simulated later:

```sh
./bin/linux-x86_64/feedsim capture.json capture.initial
```

Protocol
--------

The network protocol implemented by FEED is described in [proto.md](proto.md).

slacRfApp
---------------

Provides displays and databases geared toward SLAC production operations.

To use the screens in srcDislplay, you must incorporate srcDisplay/calc.list
into your local installation's EDM config/calc.list